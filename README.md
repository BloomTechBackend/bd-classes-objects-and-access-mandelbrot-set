# Class Applications: The Mandelbrot Set

### Background
The Manbdelbrot set is an infinitely complex, and yet self-similar
fractal made by a simple mathematical rule. 

It was first visualized in 1979, when computer graphics were starting
to become more available to mathematicians. The discovery helped
birth the field of fractal geometry, which has been used in a variety
of applications including art, file compression, to human health.

The set is generated by applying a recursive rule to each coordinate
in the complex plane.

<h3> Z<sub>n+1</sub> = Z<sub>n</sub><sup>2</sup> + C </h3>

Where both Z and C are complex numbers.

When the formula is repeated several times (each time is called an
"iteration"), one of two things happen.
Either the value shoots off into infinity, or the value bounces around
between two finite boundaries. We will be coloring each coordinate
based on how many iterations the value lasts before shooting off.

## What you will be doing

The graphical logic is already built for you. It requires some topics
we have not covered yet in the course. Your role will be that of a
programmer who is tasked with creating the complex number class 
necessary for the graphics team to build the visualization.

You have been given instructions from the mathematics team on what the
formula should do, and so your role will be to program a method which
performs the necessary calculation.


## Your Tasks

### Create the Complex Number Class, Cnum

Create a new class named Cnum.

Complex numbers in mathematics make use of the imaginary number "i",
and take the form `a + bi`.

We cannot use the number `i` directly. So instead our class needs only
to keep track to the two real values, `a` and `b`.

- Create these two fields along with a constructor which populates them.
- Create a default constructor which sets both `a` and `b` to 0.
- Create Getters and Setters for both fields.

## Complete the Methods Inside of the Main Class

### Creating Complex Number Arithmetic Operations

We aren't able to add two `Cnum`s together using the `+` operator. Nor
can we square them. So the math team won't be able to use our class
directly themselves. Instead, you'll need to design a method which 
computes the algorithm programmatically.

*For help with creating these methods and understanding algebra with 
complex numbers, see the `Concepts` section below.*

- `float getCnumMagnitude(Cnum)` Takes in a Cnum and returns its
magnitude

- `Cnum ZnPlusOne(Cnum Zn, Cnum C)` Takes in two complex numbers
and computes the next iteration of the Mandelbrot function.
    - Zn<sup>2</sup> + C
    
## A Completed Project Will:

Display the Mandelbrot set as pictured below:

## Concepts

### Recursive Math Functions

Let's look at an equation of the form:

<code>
X<sub>n+1</sub> = 2 * X<sub>n</sub> + 1
</code>

Imagine we are told that X<sub>0</sub> = 4 and we need to find X<sub>1</sub>.

<pre>
X<sub>1</sub> = 2X<sub>0</sub> + 1
X<sub>1</sub> = 2*4 + 1
X<sub>1</sub> = 8 + 1
X<sub>1</sub> = 9
</pre>

Now we can find X<sub>2</sub> which equals 2X<sub>1</sub> + 1

<pre>
X<sub>2</sub> = 2*9 + 1
X<sub>2</sub> = 18 + 1
X<sub>2</sub> = 19
</pre>

This was the first two iterations of our example equation.

Our program will perform a number of iterations according to the value
of the `DETAIL` variable at the top of the class. The starting value
is 25 iterations. If the value has not shot up towards infinity by 25
iterations, the pixel will be purple. The fewer iterations it takes,
the redder the pixel's hue.

In our program, we are using Cnums instead of integers, and will be
squaring instead of multiplying by 2.

Z<sub>n+1</sub> = Z<sub>n</sub>² + C

Where C corresponds to the pixel's coordinate on the screen.

### Adding Cnums

To add two complex numbers we must add the two real numbers, and the
two imaginary numbers.

For example

```
(1 + 2i) + (3 - 4i)
= (1+3) + (2-4)i
= 4 - 2i
```

More generally

```
(a + bi) + (c + di)
= (a+c) + (b+d)i
```

### Multiplying Cnums

Our formula requires us to square a Cnum. We'll think of this as
multiplying a Cnum together with itself. This is very similar to
multiplying polynomials but with one special rule.

The complex number `i` stands for the square root of -1. Don't worry
if you are unfamiliar with this concept. The bottom line is that
by definition `i² == -1`.

```
(a + bi) * (c + di)

//Cross multiply each term
(ac + adi) + (bci + bd*i²)

//Remember that i*i equals -1
ac + adi + bci + bd*(-1)

//Simplify
ac + adi + bci - bd

//Group Real and Imaginary terms
(ac - bd) + (ad + bc)i
```

The bottom line is the formula we desire for `Cnum` multiplication.
Since we are only squaring `Cnum`s in our project, we can simplify 
more by setting:

`a == c` and `b == d`

```
//We're really starting with
(a + bi) * (a + bi)

//Cross multiply
(a² + abi + abi + b²i²)

//Cnum(a,b)² is:
(a² - b²) + (2ab)i
```

### Magnitude of Complex Numbers

We've been talking about making sure our value does not shoot off 
to infinity. With complex numbers we have both a Real component
`a`, and an Imaginary component `b`. Either of these can grow 
infinitely.

So we instead look at the **magnitude** of the entire number. We
can get this value by finding the distance to the origin `(0,0)`.

```java
√(a² + b²)
```
